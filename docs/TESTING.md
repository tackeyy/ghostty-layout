# Testing Guide

## Overview

ghostty-layout uses [XCTest](https://developer.apple.com/documentation/xctest) as its testing framework. All code contributions must include comprehensive tests.

## Test Philosophy

- **Write tests first** when fixing bugs (TDD approach)
- **Cover all new code paths** for new features
- **No breaking changes** without tests proving backward compatibility
- **Fast execution** - unit tests should run in milliseconds

## Test Structure

### Directory Layout

```
Tests/GhosttyLayoutTests/
  GridLayoutTests.swift          # Grid parsing, description (38 tests)
  GridLayoutExecuteTests.swift   # Execution sequence verification (26 tests)
  GhosttyConfigParserTests.swift # Ghostty config file parsing (20 tests)
  ConfigTests.swift              # KeyBinding/Config Codable (19 tests)
  KeySenderTests.swift           # Modifier key mapping (15 tests)
  FileHelperTests.swift          # Symlink/permission checks (12 tests)
```

### Naming Conventions

- Test files: `*Tests.swift`
- Test classes: `final class SomethingTests: XCTestCase`
- Test methods: `func testSpecificBehavior()`

## Test Categories

### 1. Layout Parsing Tests

Test grid layout parsing from string input.

**Example** (from `GridLayoutTests.swift`):
```swift
func testParseCustom2x3() {
    let layout = GridLayout.parse("2x3")
    XCTAssertEqual(layout?.columns, 2)
    XCTAssertEqual(layout?.rows, 3)
}
```

### 2. Execution Sequence Tests

Test the key event sequences generated by layout execution using `MockKeySender`.

**Example** (from `GridLayoutExecuteTests.swift`):
```swift
func testExecute2x2Grid() {
    GridLayout(columns: 2, rows: 2).execute(keySender: mock)
    let splitHCount = mock.actions.filter { $0 == "splitH" }.count
    let splitVCount = mock.actions.filter { $0 == "splitV" }.count
    let equalizeCount = mock.actions.filter { $0 == "equalize" }.count

    XCTAssertEqual(splitHCount, 1, "2 columns = 1 splitH")
    XCTAssertEqual(splitVCount, 2, "2 columns x (2-1) rows = 2 splitV")
    XCTAssertEqual(equalizeCount, 1, "1 equalize at the end")
}
```

### 3. Config Parser Tests

Test parsing of Ghostty configuration file content.

**Example** (from `GhosttyConfigParserTests.swift`):
```swift
func testParseContentStandardConfig() {
    let content = """
    keybind = cmd+d=new_split:right
    keybind = cmd+shift+d=new_split:down
    keybind = cmd+ctrl+left=goto_split:left
    keybind = cmd+ctrl+right=goto_split:right
    keybind = cmd+ctrl+up=goto_split:up
    keybind = cmd+ctrl+down=goto_split:down
    """
    let config = GhosttyConfigParser.parseContent(content)
    XCTAssertNotNil(config)
    XCTAssertEqual(config?.splitRight.key, "d")
    XCTAssertTrue(config?.splitRight.modifiers.contains("command") ?? false)
}
```

### 4. Config Data Tests

Test configuration data structures and JSON serialization.

**Example** (from `ConfigTests.swift`):
```swift
func testKeyBindingCodableRoundTrip() throws {
    let original = KeyBinding(key: "d", modifiers: ["command", "shift"])
    let data = try JSONEncoder().encode(original)
    let decoded = try JSONDecoder().decode(KeyBinding.self, from: data)
    XCTAssertEqual(decoded.key, original.key)
    XCTAssertEqual(decoded.modifiers, original.modifiers)
}
```

### 5. Key Sender Tests

Test modifier key string-to-flag mapping.

**Example** (from `KeySenderTests.swift`):
```swift
func testModifiersFromMultiple() {
    let mods = KeySender.Modifiers.from(["command", "shift", "control"])
    XCTAssertTrue(mods.contains(.command))
    XCTAssertTrue(mods.contains(.shift))
    XCTAssertTrue(mods.contains(.control))
}
```

### 6. File Helper Tests

Test file security validation (symlinks, permissions).

**Example** (from `FileHelperTests.swift`):
```swift
func testIsSymbolicLinkWithSymlink() {
    let target = createTempFile(name: "target")
    let symlink = createSymlink(name: "link", target: target)
    XCTAssertTrue(FileHelper.isSymbolicLink(symlink))
}
```

## Writing Good Tests

### Follow AAA Pattern

```swift
func testParseCustomGrid() {
    // Arrange: Set up test data
    let input = "3x2"

    // Act: Execute the function
    let layout = GridLayout.parse(input)

    // Assert: Verify the result
    XCTAssertEqual(layout?.columns, 3)
    XCTAssertEqual(layout?.rows, 2)
}
```

### One Assertion Per Test (When Possible)

Bad:
```swift
func testParseMultipleAssertions() {
    let layout = GridLayout.parse("h")
    XCTAssertNotNil(layout)
    XCTAssertEqual(layout?.columns, 2)
    XCTAssertEqual(layout?.rows, 1)
}
```

Good:
```swift
func testParseHColumns() {
    XCTAssertEqual(GridLayout.parse("h")?.columns, 2)
}

func testParseHRows() {
    XCTAssertEqual(GridLayout.parse("h")?.rows, 1)
}
```

### Use Descriptive Test Names

Bad:
```swift
func testParse() {}
func test1() {}
```

Good:
```swift
func testParseInvalidFormatReturnsNil() {}
func testModifiersFromCaseInsensitive() {}
func testExecuteEndsWithEqualize() {}
```

### Mock External Dependencies

Use `MockKeySender` (conforming to the `KeySending` protocol) for testing execution sequences without sending real keyboard events:

```swift
final class MockKeySender: KeySending {
    var actions: [String] = []

    func splitHorizontal() { actions.append("splitH") }
    func splitVertical() { actions.append("splitV") }
    func moveLeft() { actions.append("moveL") }
    func moveRight() { actions.append("moveR") }
    func moveUp() { actions.append("moveU") }
    func moveDown() { actions.append("moveD") }
    func equalizeSplits() { actions.append("equalize") }
    func wait(_ milliseconds: UInt32) { actions.append("wait(\(milliseconds))") }
}
```

Use `setUp()` and `tearDown()` for test isolation:

```swift
var mock: MockKeySender!

override func setUp() {
    super.setUp()
    mock = MockKeySender()
}
```

### Test Edge Cases

Always test:
- Valid input (happy path)
- Invalid input (error cases)
- Boundary values (1x1, 8x8 grids)
- Empty values (`""`, `nil`)
- Case insensitivity (`"H"`, `"3X2"`)
- Malformed input (`"2y3"`, `"-1x2"`, `"x"`, `" "`)

## Running Tests

### Basic Commands

```bash
# Run all tests
swift test

# Run a specific test class
swift test --filter GridLayoutTests

# Run a specific test method
swift test --filter GridLayoutTests.testParseH

# Run tests matching a pattern
swift test --filter "Execute"
```

### Debugging Tests

```bash
# Run with verbose output
swift test -v

# Run in Xcode (for breakpoints and debugging)
open Package.swift
# Then use Cmd+U in Xcode to run tests
```

## Test Coverage Requirements

| Category | Requirement |
|----------|-------------|
| **New Features** | Tests for all new code paths |
| **Bug Fixes** | Regression test required |
| **Refactoring** | Maintain existing coverage |
| **Overall Project** | 130+ tests maintained |

## Common Testing Patterns

### Testing Config Serialization

```swift
func testConfigCodableRoundTrip() throws {
    let original = Config.defaultConfig
    let encoder = JSONEncoder()
    encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
    let data = try encoder.encode(original)
    let decoded = try JSONDecoder().decode(Config.self, from: data)

    XCTAssertEqual(decoded.splitRight.key, original.splitRight.key)
    XCTAssertEqual(decoded.splitDown.key, original.splitDown.key)
}
```

### Testing File Operations

```swift
var tempDir: URL!

override func setUp() {
    super.setUp()
    tempDir = FileManager.default.temporaryDirectory
        .appendingPathComponent("ghostty-layout-tests-\(UUID().uuidString)")
    try? FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
}

override func tearDown() {
    try? FileManager.default.removeItem(at: tempDir)
    super.tearDown()
}
```

### Testing Exact Action Sequences

```swift
func testExecute1x2ExactSequence() {
    GridLayout(columns: 1, rows: 2).execute(keySender: mock)
    XCTAssertEqual(mock.actions, ["splitV", "wait(100)", "equalize"])
}
```

## Best Practices

### DO

- Write tests before or alongside code
- Use `setUp()` / `tearDown()` to ensure test isolation
- Mock external dependencies via protocols
- Test both success and failure paths
- Use meaningful test descriptions
- Keep tests simple and focused
- Clean up temporary files in `tearDown()`

### DON'T

- Skip writing tests ("I'll add them later")
- Test implementation details (test behavior, not internals)
- Write tests that depend on other tests
- Send real keyboard events in tests
- Leave commented-out test code
- Write flaky tests (tests that sometimes fail)

## Troubleshooting

### "@testable import" fails

```bash
# Ensure the library target name matches
# In Package.swift, the library target is: GhosttyLayoutLib
@testable import GhosttyLayoutLib
```

### "Tests pass locally but fail in CI"

- Check for macOS version differences
- Ensure all file paths use `FileManager.default.temporaryDirectory`
- Do not rely on Ghostty being installed (use mocks)

### "Tests are slow"

- Avoid `usleep()` in tests; use `MockKeySender` instead
- Keep each test focused on a single behavior
- Use `XCTestCase.setUp()` for shared setup

## Resources

- [XCTest Documentation](https://developer.apple.com/documentation/xctest)
- [Swift Testing Best Practices](https://developer.apple.com/videos/play/wwdc2019/413/)
- [Testing Best Practices](https://opensource.guide/best-practices/)

## Questions?

If you have questions about testing:
1. Check existing test files for examples
2. Ask in [GitHub Discussions](https://github.com/tackeyy/ghostty-layout/discussions)
3. Open an issue with the `question` label
